
import boto3
import json
import os
import hmac
import hashlib
import base64
from botocore.exceptions import ClientError

class RealAWSService:
    def __init__(self):
        # 1. Start with defaults or environment variables
        self.config = {
            "s3_bucket": os.getenv("S3_BUCKET_NAME"),
            "dynamodb_table": os.getenv("DYNAMODB_TABLE_NAME", "PapercastCache"),
            "user_pool_id": os.getenv("COGNITO_USER_POOL_ID"),
            "client_id": os.getenv("COGNITO_CLIENT_ID"),
            "client_secret": os.getenv("COGNITO_CLIENT_SECRET"),
            "region": os.getenv("AWS_REGION", "us-east-1"),
            "aws_access_key": os.getenv("AWS_ACCESS_KEY_ID"),
            "aws_secret_key": os.getenv("AWS_SECRET_ACCESS_KEY")
        }

        # 2. If a local config file exists, use it to fill in blanks (backward compatibility)
        config_path = "infrastructure/aws_config.json"
        if os.path.exists(config_path):
            with open(config_path, "r") as f:
                file_config = json.load(f)
                for key, value in file_config.items():
                    if not self.config.get(key): # Only fill if environment variable is NOT set
                        self.config[key] = value

        # 3. Initialize clients explicitly with credentials
        session_kwargs = {
            "region_name": self.config["region"]
        }
        if self.config["aws_access_key"] and self.config["aws_secret_key"]:
            session_kwargs["aws_access_key_id"] = self.config["aws_access_key"]
            session_kwargs["aws_secret_access_key"] = self.config["aws_secret_key"]

        self.s3 = boto3.client("s3", **session_kwargs)
        self.dynamodb = boto3.resource("dynamodb", **session_kwargs)
        self.table = self.dynamodb.Table(self.config["dynamodb_table"])
        self.cognito = boto3.client("cognito-idp", **session_kwargs)
        
        self.bedrock = boto3.client("bedrock-runtime", **session_kwargs)
        self.polly = boto3.client("polly", **session_kwargs)

    def _get_secret_hash(self, username):
        """Calculates the HMAC-SHA256 secret hash for Cognito"""
        if not self.config["client_secret"]:
            return None
            
        msg = username + self.config["client_id"]
        dig = hmac.new(
            str(self.config["client_secret"]).encode('utf-8'),
            msg.encode('utf-8'),
            digestmod=hashlib.sha256
        ).digest()
        return base64.b64encode(dig).decode()

    # --- S3 (File Storage) ---
    def upload_audio(self, file_content: bytes, file_name: str) -> str:
        """Uploads audio file to S3 and returns the URL"""
        try:
            self.s3.put_object(
                Bucket=self.config["s3_bucket"],
                Key=file_name,
                Body=file_content,
                ContentType="audio/wav"
            )
            # Generating a pre-signed URL for temporary access (or use public URL if bucket is public)
            url = self.s3.generate_presigned_url(
                'get_object',
                Params={'Bucket': self.config['s3_bucket'], 'Key': file_name},
                ExpiresIn=3600  # 1 hour
            )
            return url
        except ClientError as e:
            print(f"S3 Upload Error: {e}")
            return None

    def get_audio_url(self, file_name: str) -> str:
        """Check if file exists and return a pre-signed URL"""
        try:
            self.s3.head_object(Bucket=self.config["s3_bucket"], Key=file_name)
            url = self.s3.generate_presigned_url(
                'get_object',
                Params={'Bucket': self.config['s3_bucket'], 'Key': file_name},
                ExpiresIn=3600
            )
            return url
        except ClientError:
            return None

    # --- DynamoDB (Metadata Cache) ---
    def get_article_metadata(self, article_id: str):
        """Fetch metadata from DynamoDB"""
        try:
            response = self.table.get_item(Key={'ArticleID': article_id})
            return response.get('Item')
        except ClientError as e:
            print(f"DynamoDB Get Error: {e}")
            return None

    def save_article_metadata(self, article_id: str, data: dict, user_id: str = "system"):
        """Save metadata to DynamoDB, including the UserID"""
        try:
            item = {'ArticleID': article_id, 'UserID': user_id, **data}
            self.table.put_item(Item=item)
        except ClientError as e:
            print(f"DynamoDB Put Error: {e}")

    def get_user_library(self, user_id: str):
        """Fetches all podcasts generated by a specific user"""
        try:
            # For personal projects, a scan with filter is fine. 
            # In high-volume production, you would use a GSI on UserID.
            response = self.table.scan(
                FilterExpression=boto3.dynamodb.conditions.Attr('UserID').eq(user_id)
            )
            return response.get('Items', [])
        except Exception as e:
            print(f"DynamoDB Library Error: {e}")
            return []

    # --- AI Services (Bedrock & Polly) ---
    def summarize_article(self, text: str) -> dict:
        """Uses Bedrock (Nova Micro) to generate a full suite of AI insights: Script, Summary, Key Points, and TLDR"""
        try:
            model_id = "amazon.nova-micro-v1:0"
            system_prompt = (
                "You are an AI news analyst. Your task is to extract insights from an article and return them in JSON format.\n"
                "Return a JSON object with exactly these keys:\n"
                "- 'script': A punchy, dramatic 3-sentence vintage radio script (1940s style).\n"
                "- 'summary': A 1-2 paragraph professional summary of the core news.\n"
                "- 'key_points': A list of the 3 most important facts as bullet points.\n"
                "- 'tldr': A single, punchy 'too long didn't read' sentence."
            )
            user_prompt = f"Analyze the following article and provide the insights in the requested JSON format.\n\nArticle: {text}"
            
            response = self.bedrock.converse(
                modelId=model_id,
                messages=[
                    {
                        "role": "user",
                        "content": [{"text": user_prompt}]
                    }
                ],
                system=[{"text": system_prompt}],
                inferenceConfig={
                    "maxTokens": 600,
                    "temperature": 0.5,
                    "topP": 0.9
                }
            )
            
            raw_text = response['output']['message']['content'][0]['text'].strip()
            # Basic JSON cleanup in case of markdown blocks
            if "```json" in raw_text:
                raw_text = raw_text.split("```json")[1].split("```")[0].strip()
            
            data = json.loads(raw_text)
            return data
        except Exception as e:
            print(f"Bedrock Error: {e}. Falling back to simple summary.")
            return {
                "script": text[:200] + "...",
                "summary": text[:500] + "...",
                "key_points": ["Could not extract details."],
                "tldr": "News summary unavailable."
            }

    def generate_speech(self, text: str) -> bytes:
        """Converts text to speech using AWS Polly"""
        try:
            # 'Matthew' is a clear, authoritative male voice good for news reporting
            response = self.polly.synthesize_speech(
                Text=text,
                OutputFormat="mp3",
                VoiceId="Matthew",
                Engine="standard"
            )
            return response['AudioStream'].read()
        except Exception as e:
            print(f"Polly Error: {e}")
            return None

    # --- Cognito (Authentication) ---
    def authenticate_user(self, username, password):
        """Authenticates user with Cognito and returns tokens"""
        try:
            auth_params = {
                'USERNAME': username,
                'PASSWORD': password
            }
            
            secret_hash = self._get_secret_hash(username)
            if secret_hash:
                auth_params['SECRET_HASH'] = secret_hash

            response = self.cognito.admin_initiate_auth(
                UserPoolId=self.config["user_pool_id"],
                ClientId=self.config["client_id"],
                AuthFlow='ADMIN_NO_SRP_AUTH',
                AuthParameters=auth_params
            )
            return response['AuthenticationResult']
        except ClientError as e:
            print(f"Cognito Auth Error: {e}")
            return None

    def sign_up_user(self, username, password, email):
        """Creates a new user in Cognito"""
        try:
            response = self.cognito.admin_create_user(
                UserPoolId=self.config["user_pool_id"],
                Username=username,
                UserAttributes=[
                    {'Name': 'email', 'Value': email},
                    {'Name': 'email_verified', 'Value': 'true'}
                ],
                MessageAction='SUPPRESS' # Don't send welcome email for dev
            )
            # Set password
            self.cognito.admin_set_user_password(
                UserPoolId=self.config["user_pool_id"],
                Username=username,
                Password=password,
                Permanent=True
            )
            return response
        except ClientError as e:
            print(f"Cognito Sign-up Error: {e}")
            return None

    def get_user_groups(self, username):
        """Fetches the groups a user belongs to in Cognito"""
        try:
            response = self.cognito.admin_list_groups_for_user(
                UserPoolId=self.config["user_pool_id"],
                Username=username
            )
            return [group['GroupName'] for group in response.get('Groups', [])]
        except ClientError as e:
            print(f"Cognito Groups Error: {e}")
            return []

    def get_admin_metrics(self):
        """Fetches real metrics from Cognito and DynamoDB for the Admin Dashboard"""
        metrics = {
            "total_users": 0,
            "articles_generated": 0,
            "api_cost": "Calculated..."
        }
        try:
            # 1. Total Users from Cognito (Estimated but very fast)
            cognito_res = self.cognito.describe_user_pool(UserPoolId=self.config["user_pool_id"])
            metrics["total_users"] = cognito_res['UserPool'].get('EstimatedNumberOfUsers', 0)
            
            # 2. Total Articles from DynamoDB (Live Scan Count)
            # While 'item_count' is fast but delayed (6h), scan(Select='COUNT') is live.
            # For smaller tables, this is the most reliable way to get an exact live count.
            dynamo_res = self.table.scan(Select='COUNT')
            metrics["articles_generated"] = dynamo_res.get('Count', 0)
            
        except Exception as e:
            print(f"Admin Metrics Error: {e}")
            
        return metrics

# Singleton Instance (Optional: but useful for FastAPI)
# real_aws = RealAWSService()
